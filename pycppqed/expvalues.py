import numpy
# pylab is imported directly in the plot methods.

class SubsystemTrajectory:
    def __init__(self, time, data, name, titles, number):
        self.time = time
        self.data = data
        self.name = name
        self.titles = titles
        self.number = number

    def plot(self, show=True):
        """
        Plot this subsystem.

        **Usage**
            >>> ts.plot()

        **Arguments**
            *show*
                If set True pylab.show() will be called in the end and therefor
                a window containing the plot will appear automatically.
                (Default is True)
        """
        import pylab
        title = "SubSystem %s: %s" % (self.number, self.name)
        if hasattr(pylab, "suptitle"): # For old versions not available.
            pylab.suptitle(title) 
            pylab.gcf().canvas.set_window_title(title)
        count = len(self.titles)
        for pos, title in enumerate(self.titles):
            pylab.subplot(count, 1, pos+1)
            pylab.ylabel(title)
            pylab.plot(self.time, self.data[:,pos])
        pylab.xlabel("time")
        if show:
            pylab.show()

class Subsystems(list):
    def add(self, name, subsystem):
        self.append(subsystem)
        setattr(self, name, subsystem)

    def plot(self, subsystems=None, show=True):
        """
        Plot subsystems into separate figures.

        **Usage**
            >>> tr.plot()   # Plot all subsystems.
            >>> tr.plot([1, 2]) # Plot subsystems number 1 and 2.

        **Arguments**
            *subsystems*
                Takes a list of numbers specifieing which subsystems are being
                plotted. If given None all subsystems will be plotted.
            
            *show*
                If set True pylab.show() will be called in the end and therefor
                a window containing the plot will appear automatically.
                (Default is True)
        """
        import pylab
        if subsystems is None:
            subsystems = range(len(self))
        for subsys in subsystems:
            pylab.figure(subsys)
            self[subsys].plot(show=False)
        if show:
            pylab.show()


class ExpectationValuesTrajectory:
    """
    A class for working with the expectation values generated by C++QED.
    
    **Usage**
        >>> tr = Trajectory(traj, info)
    
    **Arguments**
        * *traj*
            A nested tuple of the following structure: The outest tuple holds
            tuples for different time steps. The next inner tuples hold tuples
            for the different parameter sets.
        * *info*
            A Info object describing the data given as parameter "traj".
    """
    def __init__(self, data, time=None, titles=None, subsystems=None):
        assert len(data) > 0
        cols = len(data[0])
        if titles is None:
            titles = ()
        else:
            assert len(titles) <= cols
            titles = tuple(titles)
        titles += tuple("columnn " + str(i) for i in range(len(titles), cols))
        self.titles = numpy.array(titles)
        self.data = numpy.array(data)
        if time is None:
            self.time = self.data[:,0:1:]
        else:
            assert len(time) == len(self.data)
            self.time = numpy.array(time)
        if subsystems is None:
            subsystems = {}

        self.subsystems = Subsystems()
        i = 0
        for name, cols in subsystems.iteritems():
            a, b = cols
            sub_data = self.data[:,a:b+1:]
            sub_titles = titles[a:b+1:]
            subtraj = SubsystemTrajectory(self.time, sub_data, name,
                                          sub_titles, i)
            self.subsystems.add(name, subtraj)
            i += 1
            
    def plot(self, columns=None, show=True):
        import pylab
        if columns is None:
            columns = range(len(self.titles))
        for col in columns:
            pylab.figure(col)
            pylab.plot(self.time, self.data[:,col])
            pylab.ylabel(self.titles[col])
            pylab.xlabel("time")
        if show:
            pylab.show()


class ExpectationValueTrajectory(numpy.ndarray):
    r"""
    A class representing an expectation value to different points of time.
    """
    def __new__(cls, data, time=None, **kwargs):
        array = numpy.array(data, **kwargs).view(cls)
        if time is not None:
            array.time = time
        else:
            array.time = getattr(data, "time", None)

    def __array_finalize__(self, obj):
        self.time = getattr(obj, "time", None)


class ExpectationValueTrajectoryCollection(numpy.ndarray):
    r"""
    A class representing several expectation values at different points of time.
    """
    def __new__(cls, data, time=None, **kwargs):
        if isinstance(data, ExpectationValueTrajectory):
            array = numpy.asarray(data).reshape((1,-1)).view(cls)
        else:
            array = numpy.array(data, **kwargs).view(cls)
        if time is not None:
            array.time = time


